回顾：
笔试题：阐述volatile关键字！
1.面试题：谈谈对嵌入式的了解
  1.1.谈谈身边常见的嵌入式产品
  1.2.嵌入式定义和特点
      举例子对比说明
      硬件依赖需求
      软件依赖硬件
      立马给出一下场景
2.场景：一块开发板,一台电脑,开发板如何运行一个软件
  2.1.明确嵌入式开发基本模式
      编辑编译在上位机
      运行在下位机
      下载用网口
      此时此刻画出一个简要的开发模式示意图
      看图解决上位机和下位机将来要做的事情
  2.2.搭建上位机的嵌入式开发环境
      安装linux系统
      安装必要的软件
      	注意：软件下载利用网口,需要上位机安装配置
      	      tftpd-hpa网络服务
      	注意：上位机的IP的配置添加过程
  2.3.下位机部署(烧写)软件 
      掌控下位机的硬件信息
      	粗看
      			明确三大件
      				CPU
      				内存
      				闪存      				
      			明确外围接口
      				多种多样,哪些需要有,哪些不需要,完全依赖用户需求
      				举例子说明：手机和路由器
      				切记：网口和串口必须有！
      	细看
      			法宝：原理图和芯片手册
      			注意：具体分析哪个硬件,就看这个硬件对应的
      			      原理图和芯片手册
      	
      	总结：一旦硬件信息掌控完毕,紧接着向下位机
      	      正式部署软件
   
3.案例：以点亮和关闭下位机上4个LED灯为例
  3.1.获取点亮和关闭LED灯对应的软件(二进制可执行文件)
      resource.rar/day01/led.bin	             
  3.2.画出操作模式图
  3.3.上位机安装配置启动tftpd-hpa网络服务
      并且给上位机添加一个静态IP地址
      具体参见day01.txt的笔记即可
  3.4.问：下位机如何提供一个客户端的软件程序呢？
      答：利用大名鼎鼎的uboot软件
      问：uboot软件在哪里呢？
      答：resource.rar/day01/ubootpak.bin
      问：软件的运行和烧写位置在哪里？
          运行在内存
          烧写到闪存(EMMC)
          结论：
          	led.bin只需下载到下位机的内存并且运行即可
          	ubootpak.bin不仅仅要烧写到闪存EMMC还要运行在内存上
      问：如何在下位机先运行一个uboot呢？
      答：利用TF卡
          明确下位机的启动流程：
          上电->CPU硬件上先检测SD0卡槽是否有TF卡
          ->如果有TF卡,CPU会运行TF卡的软件
          ->如果没有TF卡,CPU会运行EMMC上的软件
      问：如何向TF卡烧写一个uboot呢？
      答：实施步骤：
       1.将TF卡插入到读卡器
       2.然后将读卡器插入到上位机上
       3.运行烧写工具：
         resource.rar/tools/IROM_Fusing_ToolV2.0.rar
         解压IROM_Fusing_ToolV2.0.rar
         得到烧写程序：IROM_Fusing_Tool.exe
         运行IROM_Fusing_Tool.exe
       4.点击"Browse"指定要烧写uboot二进制文件路径
         uboot对应的二进制文件在：
         resource.rar/day01/ubootpak.bin
         选中即可
         最后点击"Add"添加即可！
       5.最后点击"Start"开始烧写,将ubootpak.bin烧写
         到TF卡上,提示“Fusing image Done”表明烧写
         成功,烧写有问题,建议将TF卡格式化！
         烧写完毕,将TF卡拔出  
       
       6.将TF卡插入到下位机的“SD0”TF卡槽中
         一旦插入,将来上电以后,CPU会自动首先到
         SD0卡槽运行TF上的uboot
         一旦uboot运行,此时此刻下位机具有了客户端的
         功能！
    
    3.5.问：下位机TF卡上的uboot一旦运行,下位机就
             具有了客户端的功能,如何直到这个uboot
             是否正常运行了呢？  
        答：uboot软件势必有打印信息,只需在上位机
            通过串口即可捕获到下位机的uboot打印信息
        
        问：上位机如何访问串口呢？
        答：上位机获取串口信息的软件如下：
            Windows：SecureCRT
            linux：kermit或者minicom
         
        问：SecureCRT如何使用呢？
        答：操作步骤
        1.先获取SecureCRT软件
          ftp://ARM/SecureCRT_CN.zip
        2.运行SecureCRT软件
          执行：SecureCRT.exe即可
        3.SecureCRT的配置如下：
         点击左上角"快速链接"->
         协议选择“Serial”
         设置串口的工作参数：
         端口：COM1(台式机是COM1)
               如果是USB转串口,到设备管理器中
               获取对应的端口号 
         波特率：115200
         数据位：8
         奇偶校验：None
         停止位：1
         将RTS/CTS前面的勾去掉
         点击连接即可
         重启开发板(或者按Reset复位键),即可
         看到下位机TF卡上uboot的运行的信息
      
      问：linux的kermit或者minicom使用
      答：操作步骤
          linux系统安装kermit
          sudo apt-get install ckermit
          配置kermit,自行百度搜索(.kermrc)
          切记：此配置文件需要指定串口的设备文件名
                获取串口在linux系统下的设备文件名的方法：
                1.将USB转转串口插入上位机的U口
                2.执行命令dmesg,获取一堆的打印信息
                  在打印信息最后会看到串口的设备文件名类似：
                  ttyUSB0或者ttyUSB1
                3.根据获取到的串口的设备文件名来
                  修改配置文件.kermrc
          启动kermit命令：
          sudo kermit -c  
          重启下位机获取复位下位机,即可看到uboot的运行信息
       
       阶段性总结：接下来要完成的事情就是：
       1.利用TF卡上的uboot来向EMMC烧写uboot
       2.利用EMMC上的uboot来下载运行led.bin
    
    3.6.熟悉uboot相关的操作命令
       1.复位下位机,看到如下信息：
         Hit any key to stop autoboot:  3 //开始倒计时
         快速按任意键,进入uboot的命令行模式
         出现"tarena#"命令行提示符
       2.掌握uboot几个常用命令
         print命令：用于打印uboot的环境变量
                    类似linux的env命令
         关注一下几个重要的环境变量：
         ipaddr=192.168.1.110 //下位机的IP地址
         serverip=192.168.1.8 //将来下位机要从哪个上位机下载文件
         
         setenv命令：设置修改环境变量
         例如：
         setenv ipaddr 192.168.1.166
         saveenv //保存环境变量到EMMC上
         
         切记：uboot在下载文件之前,记得先测试
               网络是否连通
         ping命令：下位机ping上位机
         例如：
         			ping 192.168.1.8
         			出现：
         			ping failed; host 192.168.1.8 is not alive
         			表示网络连接失败,接着各种检查！
         			
         			出现：
         			host 192.168.1.8 is alive
         			表示网络连接成功！
         			
        tftp命令：用于从上位机下载文件到下位机的内存上
        				  此命令就是uboot的文件下载客户端软件
        切记：X6818开发板内存的基本信息如下：
        		  内存的容量为：1GB
        		  内存的起始物理地址为：0x40000000
              uboot里面的数据依赖按照16进制处理！
              
        例如：
        		tftp 0x48000000 ubootpak.bin
        		说明：从上位机下载ubootpak.bin文件到
        		      下位机的内存的起始地址为0x48000000存储空间中
        
        update_mmc命令：将内存中的数据写入到EMMC上
        例如：
        	update_mmc 2 2ndboot 0x48000000 0x200 0x78000
        说明：
        2:对应下位机的EMMC
        2ndboot:就是指定要烧写uboot,指定分区名
        0x48000000:内存的起始地址
        0x200:EMMC的起始地址,此起始地址由三星规定！
        0x78000:EMMC的存储空间的大小
        结论：从内存的0x48000000开始读取数据,将
              读取到的数据写入到EMMC的0x200起始地址
              写0x78000这么大！
              注意：单位都是字节！
      
      3.7.向EMMC烧写ubootpak.bin
          实施步骤：
          0.上位机操作：
            首先将ubootpak.bin,led.bin拷贝到
            上位机linux系统的/tftpboot目录中
            并且确保上位机的tftpd-hpa已经启动！
            
          1.复位下位机,让TF卡上的uboot先运行
          2.进入uboot命令行模式执行一下命令：
            ping 192.168.1.8 //好习惯
            tftp 48000000 ubootpak.bin
            update_mmc 2 2ndboot 0x48000000 0x200 0x78000
          3.将SD0卡槽的TF卡拔出,重新复位下位机
            看EMMC上的uboot是否运行
            至此：向EMMC烧写uboot的工作完成！
            
      3.8.向下位机下载led.bin并且运行
          1.复位下位机,让TF卡上的uboot先运行
          2.进入uboot命令行模式执行一下命令：
            ping 192.168.1.8 //好习惯
            tftp 0x48000000 led.bin
            go 0x48000000 //让CPU跑到0x48000000运行led.bin
            此时此刻观察下位机的LED灯是否交替闪烁
       
        注意：如果在下载时出现各种"T T T T...."
        (T = timeout = 超时),记得重启上位机的
        tftpd-hpa网络服务即可：
        sudo service tftpd-hpa restart          

**************************************************
二.问：led.bin从何而来？
   答：
   1.明确：从硬件层面上,计算机包括两个内容：
     CPU:数据运算和控制操作外设
          CPU一天到晚都是在跟外设进行数据的通信
          数据最终来自外设
     外设:包括CPU以外的硬件设备(U盘,硬盘,闪存,内存等)
          还包括CPU内部集成的各种硬件控制器(肉眼看不到)                    		      
     高电平=3.3V=数字1
     低电平=接地=数字0
     IO=Input/Output=输入/输出
     输入：信号线的状态由外设影响
     输出：信号线的状态由CPU影响
     GPIO:通用目的(普通)的输入或者输出引脚
     寄存器：本质和内存一模一样,存储空间很小而已！
             可以暂时存放数据信息！
             
  2.切记：CPU访问外设都是以地址指针的形式访问
    例如：向内存地址0x40000000写入4字节数据0x55555555
    C语言代码：
    *(volatile unsigned long *)0x40000000 = 0x55555555;
    结论：切记切记：CPU要想访问某个外设,必须搞清楚
          这个外设的起始物理地址！
          
  3.问：CPU到底如何访问LED灯(外设)呢？
        实现交替闪烁呢？
    答：具体实施步骤如下
    3.1.认真分析用户的需求
        目前用户需求：LED灯交替闪烁即可
    3.2.掌控LED硬件相关的信息
        粗看：
        	确认4个LED灯在开发板的位置
        	注意：如果不清楚,一定咨询硬件工程师！
        
        细看：先看原理图后看芯片手册
        	1.打开底板原理图:resource/硬件原理图/x6818bv2.pdf
        	2.找到4个LED灯在原理图的位置
        	  通过原理图得到结论：
        	  让LED1亮,只需让对应的硬件连接线GPIOC12给低电平
        	  让LED1灭,只需让对应的硬件连接线GPIOC12给高电平
        	  问：如何让GPIOC12这根硬件连接线给高低电平呢？
        	  答：GPIOC12这根硬件连接线势必最终连接到CPU上
        	  而CPU存在于核心板上,所以再次打开核心板的原理图        	  
        	3.打开核心板的原理图:resource/硬件原理图/x4418cv3_release20150713.pdf
        	  然后搜索"GPIOC12"关键字,最终得到：
        	  LED1对应的CPU引脚为:SA12/GPIOC12/SPITXD2/SDnRST2
        	  结论:LED1对应的CPU引脚具有四种复用功能:
        	  SA12:此引脚可以作为地址线(例如：内存)
        	  GPIOC12:此引脚可以作为普通的输入或者输出引脚(LED1)
        	  SPITXD2:此引脚可以作为SPI总线的发送数据的引脚
        	  SDnRST2:SD卡的Reset复位引脚
        	  结论：LED1对应的引脚目前应该选择为GPIOC12这种功能！
        	  结论：要想让LED1亮,CPU只需让GPIOC12这根引脚给低电平
        	        要想让LED1灭,CPU只需让GPIOC12这个引脚给高电平
        	        并且GPIOC12必须选择输出而不是输入！
        	  切记：此时此刻务必画出一个简要的硬件连接示意图
        	        目的是复杂的原理图简单化！
        	  问：CPU如何让GPIOC12输出0和1呢？
        	  答：CPU访问GPIOC12的操作流程：
        	  1.明确：CPU核不允许直接操作GPIOC12引脚
        	  2.CPU核通过软件编程的方式,以地址指针的
        	    形式访问GPIO控制器内部的大一堆寄存器即可
        	    本质就是CPU给GPIO控制器发送命令
        	  3.软件一旦操作完毕,GPIO控制器硬件上
        	    自动根据命令操作GPIOC12引脚
        	  4.一旦硬件操作GPIOC12引脚(高电平/低电平)
        	    最终这根硬件连接线自动影响LED1的状态
        	  5.结论：
        	    程序员最终关注的对象就是GPIO控制器以及
        	    内部的一大堆寄存器！
        	  6.此时此刻务必画出操作的示意图！
        	    参见:led.bmp
        	  
        	  问：CPU如何访问GPIO控制器以及内部的一大堆寄存器？
        	    
        	                
        	  
           		               			
         			 
         
                   
              	
          	
      